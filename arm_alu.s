#
# CMPUT 229 Student Submission License
# Version 1.0
#
# Copyright 2021 <Lukas Waschuk>
#
# Redistribution is forbidden in all circumstances. Use of this
# software without explicit authorization from the author or CMPUT 229
# Teaching Staff is prohibited.
#
# This software was produced as a solution for an assignment in the course
# CMPUT 229 - Computer Organization and Architecture I at the University of
# Alberta, Canada. This solution is confidential and remains confidential
# after it is submitted for grading.
#
# Copying any part of this solution without including this copyright notice
# is illegal.
#
# If any portion of this software is included in a solution submitted for
# grading at an educational institution, the submitter will be subject to
# the sanctions for plagiarism at that institution.
#
# If this software is found in any public website or public repository, the
# person finding it is kindly requested to immediately report, including
# the URL or other repository locating information, to the following email
# address:
#
#          cmput229@ualberta.ca
#
#---------------------------------------------------------------
# CCID:                 <lwaschuk>
# Lecture Section:      <D01>
# Instructor:           < Nelson Amaral >
# Lab Section:          <unknown>
# Teaching Assistant:   <unknown>
#---------------------------------------------------------------
# 

.data
	spacer:		.asciz	" ||||| "
	errorString:	.asciz	"Something went wrong, not a correct OPCODE"

.text
#----------------------------------
#        STUDENT SOLUTION
#----------------------------------
#---------------------------------------------------------------
# RISCVtoARM_ALU
# arguments
# 		a0 : pointer to memory containing a RISC-V function. The end of the RISC-V instructions is marked by the sentinel word 0xFFFFFFFF.
# 		a1 : where to write the solution
# returns
# 		a0 : number of bytes that the instructions generated by RISCVtoARM_ALU occupy.
#---------------------------------------------------------------
RISCVtoARM_ALU:
	addi sp,sp,-24			# sp <-- sp - 24
	sw s0, 0(sp)			# 0(sp) <-- s0
	sw s1, 4(sp)			# 4(sp) <-- s1
	sw s2, 8(sp)			# 8(sp) <-- s2
	sw s10, 12(sp)			# 12(sp) <-- s10
	sw s11, 16(sp)			# 16(sp) <-- s11
	sw ra, 20(sp)			# 20(sp) <-- ra

	mv s0, a0			# s0 <-- a0 ( move pointer to memory to s0, we need a0)
	mv s1, a1			# s1 <-- a1 ( move solution to s1)
	li s10, -1			# s10 <-- sentinal value -1
	li s11, 0 			# s11 <-- counter for the bytes
loop:
	lw s2, 0(s0)			# s2 <-- instruction to be translated
	mv a0, s2			# argument in a0
	jal translateALU		# jump to translate alu
	sw a0, 0(s1)			# a1 <-- translated arm inst
	addi s0,s0,4			# increment the pointer containing risc-v function
	addi s1,s1,4			# increment the solution file
	addi s11, s11, 4		# increment byte counter
	lw s2, 0(s0)			# s2 <-- instruction to be translated refresh it
	bne s2, s10, loop		# goto loop if s2 != -1

	mv a0, s11 			# a0 <-- counter as return value
	lw s0, 0(sp)			# s0 <-- 0(sp)
	lw s1, 4(sp)			# s1 <-- 4(sp)
	lw s2, 8(sp)			# s2 <-- 8(sp)
	lw s10, 12(sp)			# s10 <-- 12(sp)
	lw s11, 16(sp)			# s11 <-- 16(sp)
	lw ra, 20(sp)			# ra <-- 20(sp)
	addi sp,sp,24			# sp <-- sp + 24
	jr ra 				# goto ra

#---------------------------------------------------------------
# translateALU
# 	the framework for translating a risc-v program into a arm program.
#	goes line by line and translates the instructions
# 		arguments:
# 			a0: untranslated RISC-V instruction
# 		returns:
# 			a0: translated arm instruction
#---------------------------------------------------------------
translateALU:
	addi sp,sp,-28			# sp <-- sp - 28
	sw ra, 0(sp)			# 0(sp) <-- ra
	sw s0, 4(sp)			# 4(sp) <-- s0
	sw s1, 8(sp)			# 8(sp) <-- s1
	sw s2, 12(sp)			# 12(sp) <-- s2
	sw s3, 16(sp)			# 16(sp) <-- s3
	sw s4, 20(sp)			# 20(sp) <-- s4
	sw s5, 24(sp)			# 24(sp) <-- s5
	# find what the instruction OPCODE is
	mv s0, a0 			# s0 <-- untranslated risc-v code
	andi t0, s0, 0x7F		# get opcode
	li t1, 0x13			# t1 <-- opcode for i type
	li t2, 0x33			# t2 <-- opcode for r type
	li t3, 0x7F			# t3 <-- 1111111 leave
	beq t0, t1, iType		# if t0 == 0x13 goto iType
	beq t0, t2, rType		# if t0 == 0x 33 goto rType
	beq t0, t3, leave		# if opcode = FF we leave
	j error 			# if they dont match goto error and leave

iType: # after finding if it is a i-type or a r-type it will end up here
	li t1, 0x7000			# find what itype was called
	and t0, s0, t1			# t0 <-- isolated func3
	srli t0, t0, 12			# shift to the bottom
	li t1, 0x7			# t1 <-- andi
	li t2, 0x6			# t2 <-- ori
	li t3, 0x5			# t3 <-- srai or srli
	li t4, 0x1			# t4 <-- slli
	li t5, 0x0			# t5 <-- addi
	beq t0, t1, andiTranslate	# if t0 = 0x7 goto andiTranslate
	beq t0, t2, oriTranslate	# if t0 = 0x6 goto oriTranslate
	beq t0, t3, sriTranslate	# if t0 = 0x5 goto srai / srli
	beq t0, t4, slliTranslate	# if t0 = 0x1 goto slli
	beq t0, t5, addiTranslate	# if t0 = 0x0 goto addi
	j error				# if they dont match goto error and leave

andiTranslate: # if funct 3 == 0x7
	li s3, 0x0			# ARM opCode for and
	srli a0, s0, 20 		# get the immi value
	j doneiType			# goto doneiType
oriTranslate: # if funct3 == 0x6
	li s3, 0xC			# arm opcode for or
	srli a0, s0, 20 		# get the immi value
	j doneiType 			# goto doneiType
sriTranslate:# if funct3 == 0x5
	srli s5, s0, 25			# get shift type *( funct 7)
	li t1, 0			# t1 <-- 0
	li t2, 0x20			# t2 <-- 0x20
	beq s5, t1, rightLogical	# if s5 == 0x00 goto rigihtLogical
	beq s5, t2, rightArithmetic 	# if s5 == 0x20 goto rightArithmetic
	j error				# if they dont match goto error and leave
rightLogical: # if funct7 == 0x0
	li s5, 0x1			# shift type
	li s3, 0xD			# opcode
	slli s4, s0, 7			# clear top 7 bits
	srli s4,s4, 27 			# s4 <-- shift value isolated
	slli s4,s4,7			# move to correct spot, bit 7
	slli s5, s5, 5			# move shift type over by 5
	or s4, s5, s4			# combine s5 and s4
	j shiftiType			# goto shiftiType
rightArithmetic: # if funct7 == 0x20
	li s5, 0x2			# shifttype
	li s3, 0xD			# opcode
	slli s4, s0, 7			# shift over by 7 to cancel
	srli s4,s4, 27 			# s4 <-- shift value isolated
	slli s4,s4,7			# move to correct spot, bit 7
	slli s5, s5, 5			# move shift type over by 5
	or s4, s5, s4			# combine s5 and s4
	j shiftiType			# goto shiftiType
slliTranslate: # if funct3 == 0x1
	li s5, 0x0			# shift type
	li s3, 0xD			# opcode
	slli s4, s0, 7			# clear top 7 bits
	srli s4,s4, 27 			# s4 <-- imm (shift) value isolated
	slli s4,s4,7			# move to correct spot, bit 7
	slli s5, s5, 5			# move shift type over by 5 to make the 0 in bit 4
	or s4, s5, s4			# s4 is occupying bits 11 - 5
	j shiftiType			# goto shiftiType
addiTranslate: # if funct3 == 0x0
	li s3, 0x4			# arm opcode for add
	srai a0, s0, 20 		# get the immi value
	bltz a0, makePosiType		# if the value is neg, convert it to + and change the opcode
	j doneiType 			# goto dontItype
makePosiType: # if the imm was ned, change to + and change OPCode
	neg a0, a0 			# negate the bits, flipping the value from - --> +
	li s3, 0x2			# new opcode for sub
	j doneiType 			# goto doneiType
doneiType:	# everything here is the same minus the OPCODE, which is in t0, orig inst in s0
	jal computeRotation 		# goto compute rotation returns in a0, the argument is already in a0
	mv s4, a0			# s4 == rotation plus imm

	slli a0, s0, 12 		# clear top 12 bits, get <source reg>
	srli a0, a0, 27 		# put in the lowest 5 bits
	jal translateRegister 		# goto translate reg
	mv s1, a0 			# s1 == translated source reg == Rn
	slli s1, s1, 16			# put in correct place

	slli a0, s0, 20			# clear top 20 bits, get <targ reg>
	srli a0, a0, 27 		# put in lowest 5 bits
	jal translateRegister 		# goto translateReg
	mv s2, a0			# s2 <-- translated targ reg == Rm
	slli s2, s2, 12 		# put startign at bit 12

	slli s3, s3, 21 		# move to bit 21, <opcode>

	li a0, 0xE2000000		# 1110 0010 0000 0000 0000 0000 0000 0000, all the other static bits
	or a0, a0, s3			# a0 + OPCODE (21 - 24) < or everything together >
	or a0, a0, s1			# a0 + source reg ( 16 - 19 )
	or a0, a0, s2			# a0 + targ reg ( 12 - 15 )
	or a0, a0, s4 			# a0 + imm and rotation ( 0 - 11 )
	j leave				# goto leave

shiftiType:
	slli a0, s0, 12 		# clear top 12 bits <source reg>
	srli a0, a0, 27 		# put in the lowest 5 bits
	jal translateRegister 		# goto translate reg
	mv s1, a0 			# s1 == translated source reg == Rn

	slli a0, s0, 20			# clear top 20 bits <target reg>
	srli a0, a0, 27 		# put in lowest 5 bits
	jal translateRegister 		# goto translateReg
	mv s2, a0			# s2 <-- translated targ reg == Rm
	slli s2, s2, 12 		# put startign at bit 12

	slli s3, s3, 21 		# move to bit 21, <opcode>

	li a0, 0xE0000000		# 1110 0010 0000 0000 0000 0000 0000 0000 , <static bits>
	or a0, a0, s3			# a0 + OPCODE (21 - 24) < or everything together>
	or a0, a0, s1			# a0 + source reg ( 0 - 4  )
	or a0, a0, s2			# a0 + targ reg ( 12 - 15 )
	or a0, a0, s4 			# a0 + shift ( 5 - 11 )
	j leave 			# goto leave

rType: # if the opcode from above stated it is a r-type
	li t1, 0x7000			# isolate funtc 3
	and t0, s0, t1			# t0 <-- isolated func3
	srli t0, t0, 12			# shift to the bottom
	li t1, 0x7			# t1 <-- and
	li t2, 0x6			# t2 <-- or
	li t3, 0x5			# t3 <-- sra or srl
	li t4, 0x1			# t4 <-- sll
	li t5, 0x0			# t5 <-- add
	beq t0, t1, andTranslate	# if t0 = 0x7 goto andiTranslate
	beq t0, t2, orTranslate		# if t0 = 0x6 goto oriTranslate
	beq t0, t3, srTranslate		# if t0 = 0x5 goto srai / srli
	beq t0, t4, sllTranslate	# if t0 = 0x1 goto slli
	beq t0, t5, addTranslate	# if t0 = 0x0 goto addi
	j error				# goto eroor if it does not exist

andTranslate: # if funct3 == 0x7
	li s3, 0x0			# ARM opCode for and
	j donerType			# goto doenrType
orTranslate: # if funct3 == 0x6
	li s3, 0xC			# arm opcode for or
	j donerType 			# goto donerType
srTranslate: # if funct3 == 0x5
	srli s5, s0, 25			# iso funct 7
	li t1, 0			# t1 <-- 0
	li t2, 0x20			# t2 <-- 0x20
	beq s5, t1, rightLogicalR	# if s5 == 0x00 goto rigihtLogical
	beq s5, t2, rightArithmeticR	# if s5 == 0x20 goto rightArithmetic
	j error				# goto error is it does not exist
rightLogicalR: # if funct7 == 0
	li s5, 0x1			# shift type
	li s3, 0xD			# opcode
	j shiftrType			# goto shiftRType
rightArithmeticR: # if funct7 == 0x20
	li s5, 0x2			# shifttype
	li s3, 0xD			# opcode
	j shiftrType			# goto shiftRtype
sllTranslate: # if funct3 == 0x1
	li s5, 0x0			# shift type
	li s3, 0xD			# opcode
	j shiftrType			# goto shiftrType
addTranslate: # if funct3 == 0x0
	srli t0, s0, 25			# isolate funct 7
	li t1, 32			# t1 <-- 010 0000
	beq t0, t1, subTranslate	# if funct 7 == 010 0000 goto subTranslate
	li s3, 0x4			# arm opcode for add
	j donerType 			# goto donerType
subTranslate: # if funct7 == 25
	li s3, 0x2			# arm opcode for sub
	j donerType 			# goto donerType
donerType: # called with a non-shift translation
	slli a0, s0, 12 		# clear top 12 bits <SOURCE REG>
	srli a0, a0, 27 		# put in the lowest 5 bits
	jal translateRegister 		# goto translate reg
	mv s1, a0 			# s1 == translated source reg == Rn
	slli s1, s1, 16			# put in correct place

	slli a0, s0, 20			# clear top 20 bits <DEST REG>
	srli a0, a0, 27 		# put in lowest 5 bits
	jal translateRegister 		# goto translateReg
	mv s2, a0			# s2 <-- translated targ reg == Rm
	slli s2, s2, 12 		# put startign at bit 12

	slli a0, s0, 7			# clear top 20 bits <TARGET REG>
	srli a0, a0, 27 		# put in lowest 5 bits
	jal translateRegister 		# goto translateReg
	mv s4, a0			# s2 <-- translated targ reg == Rm

	slli s3, s3, 21 		# move to bit 21 <OPCODE>

	li a0, 0xE0000000		# 1110 0010 0000 0000 0000 0000 0000 0000 <STATIC BITS>
	or a0, a0, s3			# a0 + OPCODE (21 - 24) <OR EVERYTHING TOGETHER>
	or a0, a0, s1			# a0 + source reg ( 16 - 19 )
	or a0, a0, s2			# a0 + targ reg ( 12 - 15 )
	or a0, a0, s4 			# targ reg
	j leave				# goto leave


shiftrType: # called with a shift translation
	slli a0, s0, 12 		# clear top 12 bits <SOURCE REG>
	srli a0, a0, 27 		# put in the lowest 5 bits
	jal translateRegister 		# goto translate reg
	mv s1, a0 			# s1 == translated source reg == Rn

	slli a0, s0, 20			# clear top 20 bits <DEST REG>
	srli a0, a0, 27 		# put in lowest 5 bits
	jal translateRegister 		# goto translateReg
	mv s2, a0			# s2 <-- translated targ reg == Rm
	slli s2, s2, 12 		# put startign at bit 12

	slli a0, s0, 7			# clear top 20 bits <TARGET REG>
	srli a0, a0, 27 		# put in lowest 5 bits
	jal translateRegister 		# goto translateReg
	mv s4, a0			# s4 <-- translated targ reg == Rm
	slli s4,s4,8			# move to bit 8

	slli s3, s3, 21 		# move to bit 21 <OPCODE>
	slli s5, s5, 5			# move to bit 5 <SHIFT TYPE>
	li a0, 0xE0000090		# 1110 0010 0000 0000 0000 0000 1001 0000 <STATIC BITS>
	or a0, a0, s3			# a0 + OPCODE (21 - 24) < OR EVERYTHING TOGETHER >
	or a0, a0, s1			# a0 + source reg ( 0 - 4  )
	or a0, a0, s2			# a0 + targ reg ( 12 - 15 )
	or a0, a0, s4 			# a0 + shift ( 8 - 11 )
	or a0, a0, s5 			# a0 + shift type (5-7)
	j leave 			# goto leave

leave: # reload regs and return to the main ALU caller where it will exit or give new inst
	lw ra, 0(sp)			# ra <-- 0(sp)
	lw s0, 4(sp)			# s0 <-- 4(sp)
	lw s1, 8(sp)			# s1 <-- 8(sp)
	lw s2, 12(sp)			# s2 <-- 12(sp)
	lw s3, 16(sp)			# s3 <-- 16(sp)
	lw s4, 20(sp)			# s4 <-- 20(sp)
	lw s5, 24(sp)			# s5 <-- 24(sp)
	addi sp,sp,28			# sp <-- sp + 28
	jr ra 				# goto ra

error: # prints basic message if something does not align with the assumtions
	la a0, errorString		# load address into a0
	li a7, 4			# a7 <-- flag for printing strings
	ecall				# ecall <-- print the string
	li a7, 10 			# a7 <-- load exit flag
	ecall 				# exit program

#---------------------------------------------------------------
# translateRegister
# 		takes a risc-v register as a input and trasnlates it to the corresponding ARM register
# arguments
# 		a0: risc-v register to translate
# returns
#		a0: translated arm register
#---------------------------------------------------------------
translateRegister:
	li t0, 1			# t0 <-- 1
	ble a0, t0, returnAddress	# if input reg <= 1 goto returnAddress
	li t0, 2 			# t0 <-- 2
	ble a0, t0, stackPointer 	# if input reg <= 2 goto stackPointer
	li t0, 9 			# t0 <-- 7
	ble a0, t0, tempLowerSRegs	# if input reg <= 9 goto tempLowerSRegs
	li t0, 12 			# t0 <-- 12
	ble a0, t0, argRegs		# if input reg <= 12 goto argRegs
	li t0, 22			# t0 <-- 22
	ble a0, t0, upperSRegs		# if input reg <= 22 goto upperSRegs

returnAddress: # when ra is input (x1) ---> R14
	addi a0,a0,13			# 1 --> 14
	jr ra 				# goto ra
stackPointer: # when sp is input (x2) ---> R13
	addi a0,a0,11			# 2 --> 13
	jr ra 				# goto ra
tempLowerSRegs:	# when t0-t2 is input (x5-x7) ---> R0-R2
	addi a0, a0, -5 		# 5-6-7-8-9 --> 0-1-2-3-4
	jr ra 				# goto ra
argRegs: # when a0,a2 is input (x10-x12) ---> R10-R12 (do nothing)
	jr ra 				# goto ra
upperSRegs: # when s2-s6 is input (x18-x22) ---> R5-R9
	addi a0,a0,-13			# 18-19-20-21-22 --> 5-6-7-8-9
	jr ra 				# goto ra

#---------------------------------------------------------------
# computeRotation
# 		translates a risc -v immidiate into a arm imm + rotate
# arguments:
#		a0: risc-v bottom immediate in the bottom 20 bits
# returns
#		a0: rotate bits in 11-8, immediate bits in 7-0, with all other bits 0
#---------------------------------------------------------------
computeRotation:
	addi sp, sp, -12 		# sp <-- sp - 12
	sw s0, 0(sp)			# 0(sp) <-- s0
	sw s1, 4(sp)			# 4(sp) <-- s1
	sw ra, 8(sp)			# 8(sp) <-- ra

	li s0, 0			# s0 <-- counter
	li s1, 255			# s1 <-- 255 ( to check against )
	bleu a0, s1, exit		# if a0 <= 255 goto exit
rotLoop: # keeps looping around until the 8 bits that can potentially be 1 are in the bottom 8 bits
	li a1, 2			# set arg for function call, rotate by 1
	jal wrapAround 			# goto wrapAround
	addi s0,s0,2			# increment counter
	bgeu a0, s1, rotLoop		# if a0 >= 16 goto rotLoop
exit:	# when a value < 255 is found we know the bits are in the bottom 8 pos
	srli s0,s0,1			# count / 2
	slli s0,s0, 8			# move to bit 11-8
	or a0,a0,s0			# combine them together

	lw s0, 0(sp)			# s0 <-- 0(sp)
	lw s1, 4(sp)			# s1 <-- 4(sp)
	lw ra, 8(sp)			# ra <-- 8(sp)
	addi sp, sp, 12 		# sp <-- sp + 12
	jr ra 				# goto ra

#---------------------------------------------------------------
# wrapAround
#	arguments
#		a0: number to be rotated
#		a1: number to shift
#	returns
#		a0: rotated 32 bit number
#---------------------------------------------------------------
wrapAround: # no regs here to save to restore
	li t0, 32 			# t0 -> 32
	sub t1, t0, a1			# t1 <-- 32 - shift amount
	sll t2, a0, a1			# t2 <-- a0 shifted left by a1
	srl t3, a0, t1 			# t3 <-- a0 shifted right by t1 (32-shift amount)
	or t4, t2, t3			# t6 <-- wraparound shift of t1 >> t0
	mv a0, t4 			# a0 <-- t4 (rotated bit)
	jr ra 				# goto ra
